---
title: "Como usar datos climaticos para modelar variables morfologicas y fisiologicas Caso"
author: "Jorge Gonz√°lez Campos"
date: "2024-12-18"
output:
  html_document:
    toc: true            # Activa el √≠ndice
    toc_float: false      # Hace el √≠ndice flotante
    toc_position: left   # Posiciona el √≠ndice a la izquierda
    css: "styles.css"    # Enlaza un archivo CSS personalizado (opcional)
---

# **Introduci√≥n**

::: {align="justify"}
La modelaci√≥n de caracteres morfol√≥gicos y fisiol√≥gicos en especies le√±osas en relaci√≥n con variables clim√°ticas es fundamental para comprender su adaptaci√≥n y respuesta al cambio ambiental.

Mediante modelos de nicho ecol√≥gico, t√©cnicas de machine learning y simulaciones ecofisiol√≥gicas, es posible predecir patrones de crecimiento y distribuci√≥n de las especies bajo diferentes escenarios clim√°ticos.

Esta informaci√≥n es esencial para la gesti√≥n forestal, permitiendo seleccionar genotipos mejor adaptados, optimizar estrategias de silvicultura y dise√±ar planes de conservaci√≥n eficaces. Adem√°s, la modelaci√≥n facilita la identificaci√≥n de √°reas de alto riesgo por el cambio clim√°tico y contribuye a la planificaci√≥n de corredores ecol√≥gicos que favorezcan la migraci√≥n de especies en respuesta a nuevas condiciones ambientales. En un contexto de creciente variabilidad clim√°tica, integrar estos modelos en la toma de decisiones permite una gesti√≥n sostenible de los bosques y sus recursos gen√©ticos.
:::

## **1. Rasgos de plantas**

::: {align="justify"}
Los rasgos funcionales de las plantas son caracter√≠sticas que definen su forma, funci√≥n y estrategias ecol√≥gicas. Estan estrechamente vinculados a gradientes ambientales, como el clima y las propiedades del suelo

Estos rasgos son esenciales en modelos de vegetaci√≥n y en modelos acoplados clima-vegetaci√≥n, permitiendo un an√°lisis adecuado de la din√°mica de las pobalciones de una especie vegetal bajo el cambio global.
:::

### Caso de estudio: *Araucaria araucana*

::: {align="justify"}
El Pehu√©n o Araucaria (*Araucaria araucana* (Molina) K. Koch) es una de las con√≠feras nativas m√°s longevas de los bosques templados de Chile y Argentina, reconocida por su incuestionable valor cultural, social y ecol√≥gico. Esta especie posee una distribuci√≥n disyuntiva, con dos poblaciones localizadas en la Cordillera de la Costa y otras en la Cordillera de los Andes, abarcando un rango que va desde los 37¬∞ 20'S hasta los 40¬∞20'S (Bekessy et al., 2004).

![Reserva Nacional Malalcahuello, Regi√≥n de la La Araucan√≠a, Chile.](images/IMG_20210518_221701_840.jpg)
:::

::: tip
üìå **Consejo 1: Organiza tu Directorio de Trabajo**

Mantener un directorio de trabajo bien estructurado es clave para ahorrar `tiempo` y evitar confusiones. Define una carpeta espec√≠fica para tu proyecto y almacena en ella todos los archivos relacionados, como datos, scripts y resultados. Esto facilitar√° la gesti√≥n y evitar√° p√©rdidas de informaci√≥n en el futuro.
:::

Usa `setwd("ruta/del/proyecto")` en R para establecer tu directorio de trabajo.

```{r echo=FALSE, warning=FALSE, results='hide'}

rm(list = ls()) # Reiniciar el entorno
gc() # Limpiar memoria
```

```{r, echo=FALSE}

knitr::opts_knit$set(root.dir = "C:/Users/jmgon/OneDrive - Instituto Forestal/INFOR/6. Proyectos Finalizados/Proyecto SIMEF Araucaria araucana/5. Bases de Datos/Semillas")

```

## üîç Paso 1: Visualizaci√≥n del problema

::: {align="justify"}
Los datos generalmente est√°n organizados en una tabla, ¬øcierto? Seguramente tomaste varias mediciones de diferentes rasgos en individuos de las distintas poblaciones que visitaste. Estos rasgos, casi siempre, son de naturaleza morfol√≥gica y/o fisiol√≥gica.

| Pop  | Rasgo 1 | Rasgo 2 | Rasgo 3 | Latitud | Longitud |
|------|---------|---------|---------|---------|----------|
| pop1 | 10.5    | 3.4     | 8.1     | -38.5   | -73.2    |
| pop1 | 12.3    | 3.1     | 7.5     | -38.6   | -73.3    |
| pop1 | 11.8    | 3.3     | 8.2     | -38.7   | -73.4    |
| pop2 | 9.7     | 4.0     | 6.9     | -38.2   | -73.5    |
| pop2 | 8.9     | 4.1     | 7.0     | -38.1   | -73.6    |
| pop2 | 10.1    | 4.2     | 6.8     | -38.0   | -73.7    |
| pop3 | 13.2    | 5.5     | 9.0     | -39.0   | -74.0    |
| pop3 | 14.1    | 5.1     | 8.5     | -39.1   | -74.1    |
| pop3 | 12.8    | 5.3     | 9.1     | -39.2   | -74.2    |
:::

Para analizarlos de manera eficiente, es √∫til separar el flujo de trabajo en **dos procesos paralelos**:

1Ô∏è‚É£ **An√°lisis estad√≠stico de tendencias en los rasgos** 2Ô∏è‚É£ **Procesamiento de datos geoespaciales** üìç

Estos dos enfoques se trabajar√°n por separado y luego se integrar√°n para una comprensi√≥n m√°s completa.

## üîç Paso 2: Tendencias de los rasgos

::: {align="justify"}
Comencemos con el an√°lisis estad√≠stico de tendencias en los rasgos,. Si tus datos incluyen m√∫ltiples localidades o poblaciones üìç, es clave analizar c√≥mo var√≠an los rasgos en cada una. Para ello, un **gr√°fico de Ridgeline** üìà es una excelente opci√≥n, ya que permite visualizar la distribuci√≥n de los rasgos en cada poblaci√≥n, mostrando su dispersi√≥n y diferencias. Puedes usar el paquete ggridges

```{r warning=FALSE}
library(ggridges)
```

Antes de realizar pruebas estad√≠sticas, es fundamental comprender la distribuci√≥n de los datos y la medida de tendencia central m√°s adecuadaüéØ :
:::

::: tip
üìå Consejo 2:

Visualizar la distribuci√≥n de los rasgos te ayudar√° a tomar mejores decisiones sobre qu√© pruebas estad√≠sticas utilizar, asegurando un an√°lisis m√°s preciso y robusto. üöÄ
:::

```{r message=FALSE, warning=FALSE, echo=FALSE}
library(ggplot2)  # Para crear gr√°ficos y visualizaciones
library(dplyr)    # Para manipulaci√≥n de datos 
library(giscoR)   # Para descargar y trabajar con datos geoespaciales
library(maps)     # Para acceder a datos de mapas geogr√°ficos
library(readxl)   # Para leer archivos de Excel (.xlsx) en R

```

```{r, echo=FALSE, results='hide'}
## 1. Carga de datos
# Cargamos y revisamos los datos 
data_sem_imputado <- read_excel("C:/Users/jmgon/OneDrive - Instituto Forestal/INFOR/6. Proyectos Finalizados/Proyecto SIMEF Araucaria araucana/5. Bases de Datos/Semillas/data_sem_imputado.xlsx")

data_sem_imputado
```

```{r, echo=FALSE, results='hide'}
# Renombrar manualmente las columnas
data_sem_imputado <- data_sem_imputado %>%
  rename(
    rasgo1 = viabilidad_tz,
    rasgo2 = sem_semb,
    rasgo3 = sem_germe19,
    rasgo4 = porgerm_e19,
    rasgo5 = sem_germo18,
    rasgo6 = porgerm_o18,
    rasgo7 = ls_sem,
    rasgo8 = asm_sem,
    rasgo9 = abs_sem,
    rasgo10 = ps_sem,
    rasgo11 = sk_sem,
    rasgo12 = tam_embrio,
    rasgo13 = anch_embrio,
    rasgo14 = tam_anch_embrio
  )

# Verificar los nuevos nombres de las columnas
names(data_sem_imputado)

```

::: {align="justify"}
üå± En este ejemplo, el rasgo en an√°lisis corresponde al largo del embri√≥n en las semillas de Araucaria araucana. Este par√°metro morfol√≥gico es un indicador interno del desarrollo üåü que ocurre a lo largo de casi dos a√±os. Por ello, las variaciones observadas en este rasgo pueden reflejar tanto la influencia de las condiciones ambientales locales üèûÔ∏è como la diversidad intrapoblacional üåø.

En el gr√°fico, es evidente que ni la media üîµ ni la mediana üî¥ representan adecuadamente a las poblaciones costeras üåä ni a la poblaci√≥n m√°s al norte de los Andes üèîÔ∏è. Esto sugiere la presencia de patrones diferenciados entre los grupos.

üîç Este hallazgo preliminar nos indica que es necesario separar los datos en dos subconjuntos para un an√°lisis m√°s detallado y espec√≠fico. Por lo tanto, en este caso, procederemos a trabajar con las poblaciones de la costa üåä y los Andes üèîÔ∏è de manera independiente, permitiendo una mejor comprensi√≥n de las variaciones dentro de macrozona.

Al ver todas las localidades en conjunto. Se observan las tendencias centrales s:

-   **Media**: 3.15 üîµ
-   **Mediana**: 3.10 üî¥
-   **Moda**: 2.77 üü£

La **distribuci√≥n** del rasgo 12 muestra una ligera asimetr√≠a, con la **media** siendo algo m√°s alta que la **mediana**, lo que indica una leve inclinaci√≥n hacia los valores m√°s altos. Es de esperar considerando que la media es afectada por valores extremos , tales como los que se aprencian en la figura.

La **moda** es considerablemente m√°s baja que la media y la mediana, lo que sugiere que una gran parte de las observaciones est√°n agrupadas en torno a un valor m√°s b
:::

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Cargar librer√≠as necesarias
library(ggplot2)
library(ggridges)  # Para gr√°ficas de ridgeline
library(dplyr)
library(glue)

# Funci√≥n para calcular la moda
get_mode <- function(x) {
  uniq_vals <- unique(x[!is.na(x)])  # Eliminar valores NA
  uniq_vals[which.max(tabulate(match(x, uniq_vals)))]  # Devolver el valor m√°s frecuente
}


# Funci√≥n de configuraci√≥n
establecer_configuracion <- function() {
  list(
    orden_localidades = c("NAH", "VIL", "RAL", "CON", "NAL", "MAL", "LON", "ICA", "HUE", "VIR"),
    colores_localidades = setNames(
      c("#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#feb24c", "#fd8d3c", "#f03b20", "#bd0026", "#800026"),
      c("NAH", "VIL", "RAL", "CON", "NAL", "MAL", "LON", "ICA", "HUE", "VIR")
    ),
    traits = paste0("rasgo", 1:14),
    font_family = "sans",
    bg_color = "white"
  )
}

# Funci√≥n de preparaci√≥n de datos
preparar_datos <- function(data, traits, orden_localidades) {
  data %>% 
    mutate(
      across(all_of(traits), ~as.numeric(as.character(.))),
      Localidad = factor(localidad2, levels = rev(orden_localidades))
    ) %>% 
    filter(if_all(all_of(traits), ~!is.na(.)))
}

# Funci√≥n para generar gr√°fico
generar_grafico <- function(data, trait, colores_localidades, font_family, bg_color, general_mean, general_median, general_mode) {
  ggplot(data, aes(x = !!sym(trait), y = Localidad, fill = Localidad)) +
    geom_density_ridges(alpha = 0.7) + 
    geom_vline(xintercept = general_mean, color = "blue", linetype = "dashed", size = 1) +
    geom_vline(xintercept = general_median, color = "red", linetype = "dashed", size = 1) +
    geom_vline(xintercept = general_mode, color = "#8E66C1", linetype = "dashed", size = 1) +
    scale_fill_manual(values = colores_localidades) +
    labs(
      title = glue("Distribuci√≥n de {trait} por localidad"),
      subtitle = glue("Media: {round(general_mean, 2)} | Mediana: {round(general_median, 2)} | Moda: {round(general_mode, 2)}"),
      x = trait,
      y = "Localidad"
    ) +
    theme_minimal(base_family = font_family) +
    theme(
      plot.background = element_rect(fill = bg_color),
      panel.grid = element_blank(),
      plot.title = element_text(size = 12),
      plot.subtitle = element_text(size = 10),
      axis.text.y = element_text(hjust = 0),
      legend.position = "right"
    )
}

# Preparar los datos
config <- establecer_configuracion()
data_prep <- preparar_datos(data_sem_imputado, config$traits, config$orden_localidades)

# Calcular las estad√≠sticas (media, mediana, moda) para rasgo12
general_mean <- mean(data_prep$rasgo12, na.rm = TRUE)
general_median <- median(data_prep$rasgo12, na.rm = TRUE)
general_mode <- get_mode(data_prep$rasgo12)

# Generar gr√°fico para rasgo12
graficos_todos <- list()
graficos_todos[[12]] <- generar_grafico(
  data = data_prep, 
  trait = "rasgo12", 
  colores_localidades = config$colores_localidades, 
  font_family = config$font_family, 
  bg_color = config$bg_color, 
  general_mean = general_mean, 
  general_median = general_median, 
  general_mode = general_mode
)

# Mostrar gr√°fico
print(graficos_todos[[12]])

```

```{r, echo=FALSE}
library(dplyr)
library(glue)

# Funci√≥n de configuraci√≥n
establecer_configuracion <- function() {
  list(
    orden_localidades = c("NAH", "VIL", "RAL", "CON", "NAL", "MAL", "LON", "ICA", "HUE", "VIR"),
    colores_localidades = setNames(
      c("#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#feb24c", "#fd8d3c", "#f03b20", "#bd0026", "#800026"),
      c("NAH", "VIL", "RAL", "CON", "NAL", "MAL", "LON", "ICA", "HUE", "VIR")
    ),
    traits = paste0("rasgo", 1:14),
    font_family = "sans",
    bg_color = "white"
  )
}

# Funci√≥n de preparaci√≥n de datos
preparar_datos <- function(data, traits, orden_localidades) {
  data %>% 
    mutate(
      across(all_of(traits), ~as.numeric(as.character(.))),
      Localidad = factor(localidad2, levels = rev(orden_localidades))
    ) %>% 
    filter(if_all(all_of(traits), ~!is.na(.)))
}

# Funci√≥n para generar gr√°fico
generar_grafico <- function(data, trait, colores_localidades, font_family, bg_color, general_mean, general_median, general_mode) {
  ggplot(data, aes(x = !!sym(trait), y = Localidad, fill = Localidad)) +
    geom_density_ridges(alpha = 0.7) + 
    geom_vline(xintercept = general_mean, color = "blue", linetype = "dashed", size = 1) +
    geom_vline(xintercept = general_median, color = "red", linetype = "dashed", size = 1) +
    geom_vline(xintercept = general_mode, color = "#8E66C1", linetype = "dashed", size = 1) +
    scale_fill_manual(values = colores_localidades) +
    labs(
      title = glue("Distribuci√≥n de {trait} por localidad"),
      subtitle = glue("Media: {round(general_mean, 2)} | Mediana: {round(general_median, 2)} | Moda: {round(general_mode, 2)}"),
      x = trait,
      y = "Localidad"
    ) +
    theme_minimal(base_family = font_family) +
    theme(
      plot.background = element_rect(fill = bg_color),
      panel.grid = element_blank(),
      plot.title = element_text(size = 12),
      plot.subtitle = element_text(size = 10),
      axis.text.y = element_text(hjust = 0),
      legend.position = "right"
    )
}

# Preparar los datos
config <- establecer_configuracion()

# Filtrar por macrozona y preparar los datos
data_costa <- data_sem_imputado %>% filter(macrozona == "Costa")
data_andes <- data_sem_imputado %>% filter(macrozona == "Andes")

# Preparar datos para cada macrozona
data_costa_prep <- preparar_datos(data_costa, config$traits, config$orden_localidades)
data_andes_prep <- preparar_datos(data_andes, config$traits, config$orden_localidades)

# Calcular las estad√≠sticas para rasgo12 en Costa
costa_mean <- mean(data_costa_prep$rasgo12, na.rm = TRUE)
costa_median <- median(data_costa_prep$rasgo12, na.rm = TRUE)
costa_mode <- get_mode(data_costa_prep$rasgo12)

# Calcular las estad√≠sticas para rasgo12 en Andes
andes_mean <- mean(data_andes_prep$rasgo12, na.rm = TRUE)
andes_median <- median(data_andes_prep$rasgo12, na.rm = TRUE)
andes_mode <- get_mode(data_andes_prep$rasgo12)

# Generar gr√°ficos para cada macrozona (solo rasgo12)
graficos_todos <- list()

# Gr√°fico para Costa
graficos_todos$costa <- generar_grafico(
  data = data_costa_prep, 
  trait = "rasgo12", 
  colores_localidades = config$colores_localidades, 
  font_family = config$font_family, 
  bg_color = config$bg_color, 
  general_mean = costa_mean, 
  general_median = costa_median, 
  general_mode = costa_mode
)

# Gr√°fico para Andes
graficos_todos$andes <- generar_grafico(
  data = data_andes_prep, 
  trait = "rasgo12", 
  colores_localidades = config$colores_localidades, 
  font_family = config$font_family, 
  bg_color = config$bg_color, 
  general_mean = andes_mean, 
  general_median = andes_median, 
  general_mode = andes_mode
)

```

### üß¨ Subgrupo 1: Localidades costeras

::: {align="justify"}
El primero de este grupo lo refresenatn las localidades costerasüåä de *Araucaria*, incluidas **NAH** y **VIL** Los valores de las estad√≠sticas son:

-   **Media**: 2.72 üîµ
-   **Mediana**: 2.84 üî¥
-   **Moda**: 2.84 üü£

La distribuci√≥n de **rasgo12** en las localidades costeras muestra una tendencia hacia una distribuci√≥n relativamente sim√©trica y homog√©nea, con valores m√°s concentrados cerca de la **mediana** y la **moda**. La **media** y la **mediana** coinciden estrechamente, lo que indica una distribuci√≥n centrada alrededor de estos valores. Este patr√≥n sugiere que las localidades costeras tienen caracter√≠sticas relativamente consistentes, sin valores at√≠picos que influyan en la forma de la distribuci√≥n.
:::

```{r echo=FALSE, message=FALSE, warning=FALSE}
# Mostrar los gr√°ficos
print(graficos_todos$costa)

```

### üß¨ Subgrupo 2: Localidades andinas

::: {align="justify"}
En grupo **macrozona Andes**üèî, los resultados de las estad√≠sticas son:

-   **Media**: 3.25 üîµ
-   **Mediana**: 3.29 üî¥
-   **Moda**: 2.77 üü£

En otras palabras, la distribuci√≥n de los datos es **asim√©trica** y sesgada hacia la derecha (positiva), dado que la media es m√°s baja que la mediana, lo que sugiere que hay un grupo de valores m√°s altos que influyen en la media.

La moda m√°s baja (2.77) refleja que un conjunto significativo de observaciones se encuentran en torno a este valor, lo que puede indicar que una porci√≥n de las localidades tiene un comportamiento similar o valores m√°s bajos en este rasgo.

Este patr√≥n confirma la presencia de dos grupos de localidades o poblaciones con caracter√≠sticas diferentes, y se puede considerar un an√°lisis adicional para investigar por qu√© ciertos datos tienden a concentrarse en torno a la moda m√°s baja, mientras que otros valores m√°s altos afectan la media.
:::

```{r echo=FALSE, message=FALSE, warning=FALSE}
# Mostrar los gr√°ficos

print(graficos_todos$andes)
```

::: {align="justify"}
El an√°lisis y la visualizaci√≥n de las **distribuciones** de los datos son herramientas clave en la comprensi√≥n profunda de las caracter√≠sticas de un conjunto de datos. Aunque las **tendencias centrales** (como la media, la mediana y la moda) ofrecen un resumen √∫til de los datos, **la distribuci√≥n completa** permite una interpretaci√≥n m√°s rica, ya que muestra la **forma** de los datos, la **dispersion** y la posible **asimetr√≠a**.

Los **valores at√≠picos** pueden distorsionar las estad√≠sticas de tendencia central. Analizando la distribuci√≥n, podemos identificar y tratar estos valores de forma m√°s adecuada.
:::

::: tip
üìå Consejo 3:

Las distribuciones permiten detectar patrones de comportamiento que no siempre son evidentes cuando solo se analizan las estad√≠sticas centrales. Por ejemplo, es posible identificar **sesgos**, **valores at√≠picos** o **multimodalidad** (cuando hay m√°s de un pico en la distribuci√≥n) que podr√≠an influir en las conclusiones.
:::

Si se quiere hacer una comparaci√≥n m√°s formal entre distribuciones, se pueden usar pruebas estad√≠sticas como la **prueba de Kolmog√≥rov-Smirnov**, que compara la forma de dos distribuciones, o la **prueba de Mann-Whitney U**, que eval√∫a si dos distribuciones provienen de la misma poblaci√≥n sin asumir normalidad.

## üîç Paso 3: Bases de datos geograficas

::: {align="justify"}
Para el Procesamiento de datos geoespaciales, vamos a trabajar con el pol√≠gono geoespacial de **Chile**, que define los l√≠mites del pa√≠s. Los datos provienen de **GISCO**, una fuente confiable de informaci√≥n geogr√°fica. El archivo lo guardamos en formato **RDS**, que es un formato optimizado para trabajar con datos en R. Este tipo de archivo es perfecto para almacenar objetos grandes, como los datos geoespaciales, porque guarda tanto la informaci√≥n como la estructura del objeto de forma eficiente.

Este c√≥digo en R permite descargar y almacenar localmente el pol√≠gono de Chile utilizando la librer√≠a `giscoR`. Primero, se define el nombre del archivo donde se guardar√° el pol√≠gono (`chile_polygon.rds`). Luego, se intenta cargar desde el archivo local mediante `readRDS()`. Si el archivo no existe o hay un error al cargarlo, se descarga directamente desde `gisco_get_countries()` con una resoluci√≥n ajustable. Posteriormente, se guarda localmente para futuras ejecuciones con `saveRDS()`, evitando descargas innecesarias y permitiendo el uso del archivo sin conexi√≥n a internet. Finalmente, se imprime el pol√≠gono cargado o descargado para verificar su estructura. Este enfoque optimiza el tiempo de ejecuci√≥n y garantiza la disponibilidad del archivo en cualquier momento.
:::

::: tip
üìå Consejo 4:

Guardar el archivo localmente tiene varias ventajas que hacen la vida mucho m√°s f√°cil.No tenemos que perder tiempo descarg√°ndolo cada vez que corremos el c√≥digo. ¬°Esto es un ahorro de tiempo en cada ejecuci√≥n!. Adem√°s,si guardamos el archivo en nuestro equipo, no necesitamos una conexi√≥n a internet para acceder a los datos.
:::

```{r echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
library(giscoR)
library(sf)

# Definir el nombre del archivo donde se guardar√° el pol√≠gono
archivo_poligono <- file.path(getwd(), "chile_polygon.rds")

# Intentar cargar el archivo
CL <- tryCatch(
  readRDS(archivo_poligono),
  error = function(e) {
    message("‚ö†Ô∏è No se pudo cargar el pol√≠gono desde el archivo. Se proceder√° a descargarlo.")
    return(NULL)
  }
)

# Si la carga fall√≥, descargarlo nuevamente
if (is.null(CL)) {
  CL <- gisco_get_countries(
    country = "CL", 
    resolution = 3,  # Ajusta la resoluci√≥n seg√∫n sea necesario
    cache = TRUE,
    update_cache = FALSE
  )

  # Guardar el archivo para futuras ejecuciones
  saveRDS(CL, archivo_poligono)
  message("‚úÖ Pol√≠gono de Chile descargado y guardado correctamente.")
} else {
  message("‚úÖ Pol√≠gono de Chile cargado desde archivo local.")
}

# Verificar la estructura del objeto cargado
print(CL)


```

```{r echo=FALSE, message=FALSE, warning=FALSE, results='hide'}
### Obtener el pol√≠gono de Chile
CL <- gisco_get_countries(country = "CL", resolution = 3, update_cache = TRUE)

```

```{r echo=FALSE, message=TRUE, warning=FALSE, results='hide'}
### 5. Datos random
# Seleccionar una fila al azar por localidad
data_random <- data_sem_imputado %>%
  group_by(localidad2) %>%
  slice_sample(n = 1) %>%  # Seleccionar una fila al azar por grupo
  ungroup()  # Desagrupar para evitar problemas en el futuro

# Mostrar las primeras filas del resultado
print(data_random)

```

::: {align="justify"}
Una vez descargado el archivo, puedes filtrar coordenadas espec√≠ficas y generar mapas de manera eficiente para an√°lisis geoespacial.

Utilizamos la librer√≠a `giscoR` para obtener el pol√≠gono de Chile, lo que permite ubicar visualmente las localidades dentro del mapa. Posteriormente, definimos una funci√≥n que selecciona datos dentro de un rango de coordenadas determinado, simplificando el manejo y an√°lisis de las observaciones geogr√°ficas.

Con estos datos, se pueden generar mapas que superponen puntos representativos de cada localidad sobre el pol√≠gono de Chile. Adem√°s, al aplicar una paleta de colores personalizada para diferenciar cada ubicaci√≥n y a√±adir etiquetas con los nombres de las localidades, se facilita la interpretaci√≥n visual. Esto permite identificar r√°pidamente patrones espaciales en la distribuci√≥n de las observaciones.

Adem√°s, la posibilidad de mapear un rasgo espec√≠fico, como en el ejemplo, resulta particularmente √∫til para: - **Visualizar la distribuci√≥n espacial**: Identificar √°reas con valores altos o bajos de una variable. - **Detectar patrones espaciales**: Evaluar si ciertos valores del rasgo est√°n concentrados en regiones espec√≠ficas. - **Relacionar variables con el entorno**: Explorar posibles v√≠nculos entre los valores de la variable y factores clim√°ticos o ambientales.

Este enfoque no solo mejora la visualizaci√≥n de la distribuci√≥n de las poblaciones o rasgos de inter√©s, sino que tambi√©n facilita la toma de decisiones en estudios de biodiversidad, conservaci√≥n y modelamiento ecol√≥gico, permitiendo analizar relaciones espaciales y patrones geogr√°ficos.
:::

```{r, eval=FALSE}
# Cargar librer√≠as 
library(giscoR)
library(sf)  

# Obtener el pol√≠gono de Chile
CL <- gisco_get_countries(country = "CL", resolution = 3)

# Filtrar datos en un rango de coordenadas espec√≠fico
datos %>%
  filter(Latitudt >= -40 & Latitud <= -37,  Longitud  >= -74 & Longitud <= -70) %>%
  group_by(Pop, Latitud,  Longitud ) %>%
  summarise(rasgo1 = mean(rasgo1, na.rm = TRUE)) %>%
  ungroup()

# Seleccionar una fila al azar por localidad
datos_random <- datos %>%
  group_by(Pop) %>%
  slice_sample(n = 1) %>%
  ungroup()

# Crear el mapa con puntos de rasgo12
ggplot() +
  geom_sf(datatos_random = CL, fill = "#d9d9d9", color = "black") +
  geom_point(data = data_random, aes(x = Longitud , y = Latitud, color = rasgo1), size = 4, alpha = 0.8) +
  scale_color_gradient(low = "blue", high = "red", name = "Rasgo 12") +
  coord_sf(xlim = c(-74, -70), ylim = c(-40, -37)) +
  theme_minimal() +
  labs(title = "Distribuci√≥n de Rasgo12 en Localidades de Chile",
       x = "Longitud", y = "Latitud")

```

```{r echo=FALSE, message=FALSE, warning=FALSE, results='hide', fig.width=15, fig.height=10}
# Cargar librer√≠as necesarias
library(ggplot2)
library(dplyr)
library(giscoR)
library(sf)          # Para manejo de datos espaciales

# Obtener el pol√≠gono de Chile
CL <- gisco_get_countries(country = "CL", resolution = 3)

# Definir el vector de traits
traits <- paste0("rasgo", 1:14)

# Funci√≥n para filtrar y resumir datos
filtrar_datos_chile <- function(data, lat_min, lat_max, lon_min, lon_max) {
  data %>%
    filter(lat >= lat_min & lat <= lat_max,     # Rango de latitudes
           lon >= lon_min & lon <= lon_max) %>% # Rango de longitudes
    group_by(localidad2, lat, lon) %>%
    summarise(
      rasgo1 = mean(rasgo1, na.rm = TRUE),    # Cambiar a rasgo1
      rasgo12 = mean(rasgo12, na.rm = TRUE),  # Cambiar a rasgo12
      rasgo13 = mean(rasgo13, na.rm = TRUE)   # Cambiar a rasgo13
    ) %>%
    ungroup()
}

# Filtrar datos dentro del rango espec√≠fico
data_filtrado <- filtrar_datos_chile(
  data_sem_imputado, lat_min = -40, lat_max = -37, lon_min = -80, lon_max = -70
)

# Verificar si hay datos v√°lidos
if (nrow(data_filtrado) == 0) {
  stop("No hay datos disponibles para el rango de coordenadas seleccionado.")
}

# Seleccionar una fila al azar por localidad para los puntos del mapa
data_random <- data_filtrado %>%
  group_by(localidad2) %>%
  slice_sample(n = 1) %>%
  ungroup()

# Crear el mapa de Chile con etiquetas para cada localidad
# Aseg√∫rate de que la configuraci√≥n est√© correctamente cargada
config <- establecer_configuracion()

# Crear el mapa de Chile con etiquetas para cada localidad
mapa <- ggplot() +
  geom_sf(data = CL, fill = "#d9d9d9", color = "black") +   # Pol√≠gono de Chile
  geom_point(data = data_random, 
             aes(x = lon, y = lat, color = localidad2),     # Asignar color a los puntos por localidad
             size = 5, alpha = 0.8) +                        # Puntos para localidades
  geom_text(data = data_random, 
            aes(x = lon, y = lat, label = localidad2, color = localidad2),  # Asignar color a las etiquetas
            size = 3, vjust = -1) +                          # Ajustar posici√≥n y color de las etiquetas
  coord_sf(xlim = c(-74, -70), ylim = c(-40, -37)) +          # Limitar la regi√≥n de inter√©s
  scale_color_manual(values = config$colores_localidades,     # Usar colores definidos en la configuraci√≥n
                     name = "Localidad") +                   # Cambiar el nombre de la leyenda a "Localidad"
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),  # T√≠tulo de mismo tama√±o
    plot.subtitle = element_text(size = 12, hjust = 0.5),
    axis.title = element_text(size = 10)
  ) +
  labs(title = "Localidades de Araucaria araucana",
       x = "Longitud", 
       y = "Latitud")


# Crear el mapa con puntos de rasgo12
mapa2 <- ggplot() +
  geom_sf(data = CL, fill = "#d9d9d9", color = "black") +
  geom_point(data = data_random, aes(x = lon, y = lat, color = rasgo12), size = 4, alpha = 0.8) +
  scale_color_gradient(low = "blue", high = "red", name = "Rasgo 12") +
  coord_sf(xlim = c(-74, -70), ylim = c(-40, -37)) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),  # T√≠tulo de mismo tama√±o
    plot.subtitle = element_text(size = 12, hjust = 0.5),
    axis.title = element_text(size = 10)
  ) +
  labs(title = "Distribuci√≥n de Rasgo12 en Localidades",
       x = "Longitud",
       y = "Latitud")

# Mostrar los mapas en una sola visualizaci√≥n
library(gridExtra)
gridExtra::grid.arrange(mapa, mapa2, ncol = 2)

```

## üîç Paso 4: Base de datos climaticos

::: {align="justify"}
En cuanto a las bases de datos, existen algunas ampliamente utilizadas en proyectos de an√°lisis clim√°tico, ecol√≥gico y geogr√°fico. La elecci√≥n depender√° de los objetivos espec√≠ficos y de los resultados que desees obtener. A continuaci√≥n, te presento las m√°s usadas:

**CHELSA (Climatologies at High Resolution for the Earth's Land Surface Areas)**

CHELSA es un conjunto de datos clim√°ticos de alta resoluci√≥n (30 segundos de arco) que proporciona informaci√≥n sobre la temperatura, precipitaci√≥n, humedad y otras variables clim√°ticas para √°reas terrestres a nivel global. Es especialmente √∫til para estudios de ecolog√≠a, biogeograf√≠a y cambio clim√°tico, con datos de 1950 a la fecha.

[![Climatologies at high resolution for the earth\'s land surface areas](images/chelsa.jpg){width="161" height="49"}](https://chelsa-climate.org/)

**WorldClim**

WorldClim es una de las bases de datos m√°s utilizadas para estudios de modelado clim√°tico, ofreciendo datos hist√≥ricos y de proyecciones futuras sobre variables clim√°ticas globales, como temperatura, precipitaci√≥n y humedad relativa. Los datos est√°n disponibles a diferentes resoluciones espaciales, desde 1 km hasta 10 km, y cubren tanto condiciones actuales como escenarios futuros basados en modelos clim√°ticos.

[![](images/worldclim.jpg){width="162"}](https://www.worldclim.org/)

**MODIS (Moderate Resolution Imaging Spectroradiometer)**

MODIS es un instrumento satelital a bordo de los sat√©lites Terra y Aqua de la NASA. Proporciona datos de observaci√≥n de la tierra en una resoluci√≥n moderada (250 m a 1 km) sobre variables como la cobertura terrestre, la temperatura de la superficie del mar, la radiaci√≥n solar y otras caracter√≠sticas ambientales. Es utilizado ampliamente en estudios de uso del suelo, din√°mica de ecosistemas y monitoreo de fen√≥menos clim√°ticos globales.

[![](images/modis.png){width="161"}](https://modis.gsfc.nasa.gov/)

üí° Te explico c√≥mo hacerlo.

En este paso, descargaremos los datos clim√°ticos desde la p√°gina oficial de **WorldClim**. Estos datos son fundamentales para realizar an√°lisis ambientales y ecol√≥gicos. WorldClim ofrece un conjunto de **19 variables bioclim√°ticas**, que se derivan principalmente de las mediciones de temperatura y precipitaci√≥n.

Los datos se obtienen con una resoluci√≥n espacial espec√≠fica (en este caso, 2.5 minutos) y se almacenan en un directorio local para facilitar su acceso futuro. Una vez descargados, exploramos su estructura para identificar las 19 variables bioclim√°ticas disponibles. Si el an√°lisis est√° enfocado en una regi√≥n particular, como Chile, podemos recortar los datos utilizando un rango de coordenadas o un pol√≠gono que delimite el √°rea de inter√©s. Esto nos permite visualizar mapas y trabajar directamente con los datos en el √°rea seleccionada. Por ejemplo, podemos extraer valores espec√≠ficos de las variables para localidades particulares, facilitando su uso en an√°lisis de biodiversidad, modelamiento ecol√≥gico o estudios clim√°ticos. Este enfoque asegura que los datos sean relevantes y espec√≠ficos para los objetivos del proyecto, optimizando su aplicaci√≥n en investigaciones.
:::

```{r echo=FALSE, message=FALSE, warning=FALSE, results='hide'}
# 2. Descargar datos clim√°ticos (ejemplo con raster para WorldClim)
library(geodata)
climate_data <- worldclim_global(
  var = "bio", 
  res = 2.5, 
  path = "C:/Users/jmgon/OneDrive - Instituto Forestal/Lista de R Script/Script Proyecto Araucaria/worldclim_data"
)
```

```{r, eval=FALSE}
datos_climaticos <- worldclim_global(
  var = "bio", 
  res = 2.5, 
  path = "~/worldclim_data"
)
```

Donde:

var = "bio": Especifica que se quieren descargar las variables bioclim√°ticas, que son un conjunto de 19 variables derivadas de la temperatura y precipitaci√≥n.

res = 2.5: Establece la resoluci√≥n espacial de los datos. En este caso, se especifica una resoluci√≥n de 2.5 minutos de arco (aproximadamente 4.5 km).

path = "\~/worldclim_data": Indica la carpeta donde se almacenar√°n los archivos descargados.

## üîç Paso 5: Extracci√≥n de valores de raster en puntos

Utilizando las coordenadas geogr√°ficas de los localidades o poblaciones donde hiciste las colectas de datos, ylos datos clim√°ticos del raster obtenido de wordclim, obtienes un conjunto de datos enriquecido que contiene tanto las caracter√≠sticas de ubicaci√≥n (coordenadas geogr√°ficas) como las variables clim√°ticas asociadas a cada punto. Esto te permite realizar an√°lisis espaciales y ecol√≥gicos m√°s completos.

::: tip
üìå Consejo 5:

Es importante que las coordenadas de lat y lon coincidan entre los datos y el raster para que las variables clim√°ticas se asocien correctamente a cada punto. Vamos a hacer un anal
:::

```{r echo=FALSE, message=FALSE, warning=FALSE, results='hide'}

coords <- data.frame(lon = data_filtrado$lon, lat = data_filtrado$lat)
coords
```

```{r echo=FALSE, message=FALSE, warning=FALSE, results='hide'}
data_filtrado <- data_filtrado[-241,]
data_filtrado
```

```{r, echo=FALSE, results='hide'}
climate_values <- extract(climate_data, coords)
climate_values
```

```{r, echo=FALSE, results='hide'}

climate_values<- na.omit(climate_values)
climate_values

```

```{r, echo=FALSE, results='hide'}
dim(climate_values)
```

```{r, echo=FALSE, results='hide'}

# 4. Combinar variables clim√°ticas con viabilidad_tz
data_climate <- cbind(data_filtrado, climate_values)
names(data_climate)
data_climate
```

```{r, eval=FALSE}
data_full <- cbind(datos_rasgos, datos_climaticos)

```

```{r, echo=FALSE, results='hide'}
# Crear subconjunto para Costa
data_costa <- subset(data_climate, localidad2 %in% c( "VIL", "NAH"))

# Crear subconjunto para Andes
data_andes <- subset(data_climate, localidad2 %in% c("RAL", "CON","NAL", "MAL", "LON", "ICA", "HUE", "VIR"))

# Verificar los resultados
head(data_costa)
head(data_andes)

```

## üîç Paso 6: An√°lisis de Componentes Principales

::: {align="justify"}
El An√°lisis de Componentes Principales (PCA) es una t√©cnica estad√≠stica clave cuando se trabaja con datos clim√°ticos, ya que permite reducir la dimensionalidad de grandes vol√∫menes de datos mientras se conserva la mayor parte de la variabilidad.

En este contexto, el PCA puede ser utilizado para analizar un conjunto de variables clim√°ticas, como temperatura, precipitaci√≥n, humedad, radiaci√≥n solar, entre otras. Estas variables, que a menudo est√°n altamente correlacionadas, se transforman en un conjunto m√°s peque√±o de componentes principales, los cuales son combinaciones lineales de las variables originales.

Este enfoque facilita la identificaci√≥n de patrones subyacentes en los datos, como los principales factores que explican las variaciones clim√°ticas en distintas regiones geogr√°ficas. Al reducir las dimensiones de los datos clim√°ticos, el PCA no solo simplifica el an√°lisis, sino que tambi√©n permite una mejor visualizaci√≥n y comprensi√≥n de la estructura espacial y temporal de los fen√≥menos clim√°ticos.
:::

```{r echo=FALSE, warning=FALSE, results='hide'}
# Realizar el PCA
pca_result <- prcomp(data_andes[,c(8:26)], center = TRUE, scale. = TRUE)

# Resumen del PCA
summary(pca_result)

```

```{r, echo=FALSE, results='hide'}
# Agregar los componentes principales al conjunto de datos original
data_climate_full <- cbind(data_andes, pca_result$x)

```

::: {align="justify"}
Podemos tener una visualizaci√≥n 3D que nos permita observar la relaci√≥n entre los componentes principales (PC1, PC2, y PC3) y el rasgo quee estemos evaluando.

üí° Te explico c√≥mo hacerlo.

Los ejes X, Y y Z del gr√°fico corresponden a los componentes principales (PC1, PC2 y PC3), lo que nos permite entender c√≥mo se agrupan las observaciones en funci√≥n de sus caracter√≠sticas clim√°ticas.

La escala de color azul (valores bajos) hasta rojo (valores altos), refleja la magnitud del rasgo "rasgo12" para cada observaci√≥n. Este rasgo podr√≠a ser, por ejemplo, el tama√±o de la semilla o alguna otra caracter√≠stica medida.

As√≠, no solo estamos observando c√≥mo se distribuyen las localidades en un espacio tridimensional, sino que tambi√©n estamos incorporando la informaci√≥n sobre la variabilidad del rasgo evaluado a trav√©s de la escala de colores. Este tipo de visualizaci√≥n nos ayuda a identificar patrones en c√≥mo el rasgo var√≠a en relaci√≥n con los componentes principales, proporcionando una visi√≥n clara y detallada de las relaciones entre los datos.
:::

### üå≥ Biplot rasgo 12 componentes principales

```{r message=FALSE, warning=FALSE, emessage=FALSE, paged.print=FALSE}
library(plotly)

# Crear el gr√°fico 3D
plot_ly(
  data = data_climate_full,
  x = ~PC1, y = ~PC2, z = ~PC3, 
  color = ~rasgo12, 
  colors = colorRampPalette(c("blue", "red"))(100),
  type = "scatter3d", 
  mode = "markers",
  marker = list(size = 5, opacity = 0.8)
) %>%
  layout(
    scene = list(
      xaxis = list(title = "PC1"),
      yaxis = list(title = "PC2"),
      zaxis = list(title = "PC3")
    )
  )


```

```{r echo=FALSE, message=FALSE, warning=FALSE, results='hide'}
library(plotly)
library(RColorBrewer)

# Definir el orden deseado para la leyenda y colores manualmente
orden_localidades <- c("RAL", "CON", "NAL", "MAL", "LON", "ICA", "HUE", "VIR")
colores_localidades <- c("#41b6c4", "#1d91c0", "#225ea8", "#feb24c", "#fd8d3c", "#f03b20", "#bd0026", "#800026")

# Asignar los colores manualmente a las localidades
pca_scores <- data.frame(pca_result$x)  # Extraer los scores de las observaciones
pca_scores$localidad2 <- data_climate_full$localidad2  # Asegurarse de que localidad2 est√© presente

# Mapear los colores a las localidades manualmente
colores_mapped <- colores_localidades[match(pca_scores$localidad2, orden_localidades)]

```

### üå≥ Biplot localidades componentes principales

```{r echo= TRUE, message=FALSE, warning=FALSE}
# Crear el gr√°fico 3D con la localidad ordenada y los colores personalizados
plot_ly(
  data = pca_scores,
  x = ~PC1, y = ~PC2, z = ~PC3,  # Usando PC3 como variable en el eje z
  color = I(colores_mapped),       # Usar los colores manualmente asignados
  type = "scatter3d", mode = "markers",  # Definir el tipo de gr√°fico
  marker = list(size = 4, opacity = 0.8)  # Tama√±o y opacidad de los puntos
) %>%
  layout(
    title = "Gr√°fico 3D: Relaci√≥n entre PC1, PC2 y PC3",
    scene = list(
      xaxis = list(title = "PC1"),
      yaxis = list(title = "PC2"),
      zaxis = list(title = "PC3")
    ),
    legend = list(title = list(text = "Localidad")),  # T√≠tulo para la leyenda
    colorbar = list(
      title = "Localidad",
      tickvals = seq(1, length(orden_localidades), by = 1),  # valores del color
      ticktext = orden_localidades,  # texto de las localidades
      tickcolor = colores_localidades  # asignar colores a la leyenda
    )
  )
```

## üîç Paso 6:Modelamiento

::: {align="justify"}
El modelamiento con componentes clim√°ticos permite realizar predicciones sobre un rasgo en particular utilizando informaci√≥n derivada de las condiciones ambientales. Este enfoque es particularmente √∫til en estudios ecol√≥gicos, agr√≠colas y de biodiversidad, ya que combina datos clim√°ticos con caracter√≠sticas espec√≠ficas de inter√©s, como rasgos fisiol√≥gicos o morfol√≥gicos.

Para ello, los datos clim√°ticos se resumen en componentes principales (mediante an√°lisis de PCA) o se utilizan directamente como predictores. A partir de esto, se aplican distintos modelos seg√∫n la naturaleza de los datos y los objetivos del an√°lisis. Entre los modelos m√°s com√∫nmente utilizados se encuentran:

1.  **Modelos lineales m√∫ltiples (LM):** √ötiles para explorar relaciones lineales entre los componentes clim√°ticos y un rasgo espec√≠fico. Son simples, interpretables y proporcionan una base para comparaciones iniciales.

2.  **Modelos Aditivos Generalizados (GAM):** Permiten modelar relaciones no lineales entre las variables clim√°ticas y los rasgos. Son ideales cuando se sospecha de patrones complejos o curvil√≠neos.

3.  **Modelos de M√°quinas de Soporte Vectorial (SVM):** Aplicados para predicciones m√°s avanzadas, especialmente en escenarios no lineales con m√∫ltiples dimensiones.

4.  **Modelos de Bosques Aleatorios (RF):** √ötiles para capturar interacciones entre m√∫ltiples variables clim√°ticas y para identificar la importancia relativa de cada predictor.

5.  **Redes Neuronales Artificiales (ANN):** Recomendados para datos grandes y complejos, donde las relaciones entre las variables pueden ser altamente no lineales y dif√≠ciles de modelar con enfoques tradicionales.

El modelo seleccionado depender√° de los objetivos espec√≠ficos del proyecto, el tipo de datos disponibles y el nivel de complejidad esperado. Este enfoque asegura que se aproveche al m√°ximo la informaci√≥n clim√°tica para hacer predicciones precisas y relevantes, facilitando una mejor comprensi√≥n de los patrones y relaciones entre el clima y los rasgos estudiados.
:::

```{r, echo=FALSE, results='hide'}
# Definir las variables dependientes
variables_dependientes <- c("rasgo1", "rasgo12", "rasgo13")

# Inicializar una lista para almacenar los modelos
modelos <- list()

# Loop para ajustar los modelos y almacenarlos
for (var in variables_dependientes) {
  # Ajustar el modelo
  modelo <- lm(as.formula(paste(var, "~ PC1 + PC2 + PC3 + PC4")), data = data_climate_full)
  
  # Guardar el modelo en la lista
  modelos[[var]] <- modelo
  
  # Mostrar el resumen del modelo
  print(paste("Resumen del modelo para", var))
  print(summary(modelo))
}

```

### üå≥ Ejemplo con un modelo lineal

::: {align="justify"}
Los primeros 4 componentes principales de las variables clim√°ticas explican el **42% de la varianza del rasgo 12**. Es decir, si bien su crecimiento est√° modelado clim√°ticamente en el subgrupo de localidades de los Andes (recordar que separamos en dos grupos para mejorar el an√°lisis), **la otra parte de la variabilidad podr√≠a estar sujeta a factores gen√©ticos y/o ed√°ficos** (suelo), los cuales no fueron incluidos en este ejemplo. Sin embargo, su influencia ha sido demostrada en estudios previos (*ver Joswig et al., 2021* <https://doi.org/10.1038/s41559-021-01616-8>).

A continuaci√≥n, se presenta el modelo lineal ajustado para el rasgo 12 en funci√≥n de los **4 primeros componentes principales del clima**:
:::

```{r echo=FALSE, message=FALSE, warning=FALSE}
modelo <- lm(rasgo12 ~ PC1 + PC2 + PC3 + PC4, data = data_climate_full)
summary(modelo)
```

```{r message=FALSE, warning=FALSE, echo=FALSE}
# Cargar librer√≠as necesarias
library(ggplot2)

# Definir las variables dependientes
variables_dependientes <- c("rasgo1", "rasgo12", "rasgo13")

# Inicializar una lista para almacenar los modelos
modelos <- list()
graficos <- list()

# Loop para ajustar los modelos, almacenarlos y generar gr√°ficos
for (var in variables_dependientes) {
  # Ajustar el modelo de regresi√≥n m√∫ltiple
  modelo <- lm(as.formula(paste(var, "~ PC1 + PC2 + PC3 + PC4")), data = data_climate_full)
  
  # Guardar el modelo en la lista
  modelos[[var]] <- modelo
  
  # Obtener valores observados y predichos
  datos_grafico <- data.frame(
    Observado = data_climate_full[[var]],
    Predicho = predict(modelo)
  )
  
  # Generar el gr√°fico Observado vs Predicho
  graficos[[var]] <- ggplot(datos_grafico, aes(x = Predicho, y = Observado)) +
    geom_point(alpha = 0.6, color = "blue") +  # Puntos
    geom_smooth(method = "lm", color = "black", linetype = "dashed") +  # L√≠nea de regresi√≥n
    geom_abline(slope = 1, intercept = 0, color = "red", linetype = "solid") +  # L√≠nea ideal y = x
    labs(
      title = paste("Gr√°fico Observado vs Predicho para", var),
      x = "Valor Predicho",
      y = "Valor Observado"
    ) +
    theme_minimal()
}

# Mostrar los gr√°ficos
#print(graficos$rasgo1)
print(graficos$rasgo12)
#print(graficos$rasgo13)

```

::: tip
üìå Consejo 6:

Si encuentras que algunos paquetes no funcionan correctamente, o si has actualizado R recientemente, es recomendable usar este comando para asegurarte de que todos los paquetes est√©n actualizados y sean compatibles con la versi√≥n actual de R.
:::

```{r, eval=FALSE}
update.packages(ask = FALSE, checkBuilt = TRUE)

```

[![üìä Estad√≠stica Aplicada - Data Science üìß Correo: jm.gonzalezc\@outlook.com üìç Ubicaci√≥n: Chile](images/Foto-60_websize.jpg){width="213"}](https://www.linkedin.com/in/jorgemauriciog/)
